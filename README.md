# JavaLearning

#### Я изучил аннотацию @SpringBootApplication. Если кратко, то эта аннотация заменяет @EnableAutoConfiguration , @Configuration и @ComponentScan. 

___

>***@EnableAutoConfiguration*** — включает механизм автоконфигурации. Автоконфигурация означает автоматическое создание bean-компонентов путем сканирования пути к классам. 

___

>***@ComponentScan*** — обычно в приложении, такие аннотации, как @Component, @Configuration, @Service, @Repository, указываются в классах, чтобы пометить их как компоненты Spring. Аннотация @ComponentScan в основном говорит Spring Boot сканировать текущий пакет и его подпакеты, чтобы идентифицировать аннотированные классы и настроить их как Spring bean-компоненты. Таким образом, текущий пакет назначается корневым для сканирования компонентов. 

___

>***@Configuration*** — определяет класс как класс конфигурации для конфигурация Java. В дополнение к bean-компонентам, настроенным с помощью сканирования компонентов, приложению может потребоваться настроить некоторые дополнительные bean-компоненты с помощью аннотации @Bean, как показано ниже.здесь. Таким образом, возвращаемое значение методов, имеющих аннотацию @Bean в этом классе, регистрируется как bean-компоненты. 
___

#### Свойства аннотации @SpringBootApplication: ####
  1. ***exclude*** - исключает определенные классы автоматической настройки, чтобы они никогда не применялись.
  2. ***excludeName*** - тоже, что и exlude.
  3. ***scanBasePackages*** - базовые пакеты для сканирования аннотированных компонентов.
  4. ***scanBasePackageClasses*** - типобезопасная альтернатива указанию пакетов для сканирования аннотированных компонентов ( scanBasePackages() ). Пакет каждого указанного класса будет просканирован.
  5. ***nameGenerator*** - класс BeanNameGenerator, который будет использоваться для именования обнаруженных компонентов в контейнере Spring.
  6. ***proxyBeanMethods*** - укажите, должны ли @Bean методы быть проксированы, чтобы обеспечить необходимое поведение жизненного цикла компонента, например, чтобы возвращать общие экземпляры одноэлементного компонента даже в случае прямого @Bean вызова метода в коде. Для этой функции требуется перехват метода, реализованный через подкласс CGLIB, созданный во время выполнения, который имеет такие ограничения, как класс конфигурации и его методы, которым не разрешено объявлять файлы final.
